---
import Layout from "../../layouts/Layout.astro";
import Card from "../../components/Card.astro";
import pb from "../../utils/pb.js";
import { Collections } from "../../utils/pocketbase-types.js";
import { ui } from "../../i18n/ui.js";

const locale = Astro.locals.lang ?? 'en';
const user = Astro.locals.user; // Récupère l'utilisateur connecté

let svgs: any[] = [];

// Vérifier si l'utilisateur est connecté
if (user && user.id) {
  try {
    // Récupérer uniquement les SVGs de l'utilisateur connecté avec les tags
    svgs = await pb
      .collection(Collections.Svg)
      .getFullList({
        sort: "-created", // Trie les SVGs du plus récent au plus ancien
        filter: `user = "${user.id}"`, // Filtre pour n'afficher que les SVGs de l'utilisateur
        expand: "tags", // Charge les informations complètes des tags
      });
    console.log(`✅ ${svgs.length} SVG(s) trouvé(s) pour l'utilisateur ${user.id}`);
  } catch (error) {
    console.error('Erreur lors du chargement des SVGs:', error);
  }
} else {
  console.log('⚠️ Aucun utilisateur connecté');
}
---

<Layout>
  <div class="min-h-screen bg-base-200 p-4">
    <div class="max-w-6xl mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold">{ui[locale].gallery.title}</h1>
        <button 
          class="btn btn-outline gap-2"
          onclick="openManageTagsModal()"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
          </svg>
          {ui[locale].gallery.manageAllTags}
        </button>
      </div>
      
      <!-- Barre de recherche et filtres -->
      <div class="mb-6 space-y-4">
        <div class="flex flex-col sm:flex-row gap-3">
          <!-- Recherche par nom -->
          <div class="flex-1">
            <div class="relative">
              <input 
                type="text" 
                id="search-input"
                placeholder={ui[locale].gallery.searchPlaceholder}
                class="input input-bordered w-full pl-10"
              />
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-base-content/50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </div>
          </div>
          
          <!-- Filtre par tags -->
          <select id="tag-filter" class="select select-bordered min-w-[200px]">
            <option value="">{ui[locale].gallery.allTags}</option>
          </select>
        </div>

        <!-- Tags sélectionnés -->
        <div id="selected-tags" class="flex flex-wrap gap-2 empty:hidden"></div>
      </div>
      
      <!-- Message "Aucun résultat" -->
      <div id="no-results" class="hidden text-center py-8">
        <p class="text-base-content/60">{ui[locale].gallery.noResults}</p>
      </div>

      <div id="svg-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {svgs.length > 0 ? (
          svgs.map((svg) => (
            <Card svg={svg} locale={locale} />
          ))
        ) : (
          <div class="text-center py-8 col-span-full">
            <div class="flex flex-col items-center space-y-4">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
              <div>
                <p class="text-gray-600 text-lg font-medium">{ui[locale].gallery.noSvgFound}</p>
              </div>
              <a href="/generator" class="btn btn-primary mt-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                </svg>
                {ui[locale].gallery.createFirstSvg}
              </a>
            </div>
          </div>
        )}
      </div>
    </div>
  </div>
</Layout>

<!-- Passer les traductions au script -->
<script type="application/json" id="translations" data-locale={locale} set:html={JSON.stringify(ui[locale].gallery)}></script>

<script>
  // Récupérer les traductions
  const translationsElement = document.getElementById('translations');
  const translations = translationsElement ? JSON.parse(translationsElement.textContent || '{}') : {};

  // Fonction pour copier le code SVG
  async function copySVGCode(id: string, code: string) {
    try {
      await navigator.clipboard.writeText(code);
      alert(translations.codeCopied || 'Code SVG copié dans le presse-papiers !');
    } catch (error) {
      console.error('Erreur lors de la copie:', error);
      alert(translations.copyError || 'Erreur lors de la copie');
    }
  }

  // Fonction pour supprimer un SVG (Pour le frontend)
  async function deleteSVGItem(id: string) {
    if (confirm(translations.confirmDelete || 'Êtes-vous sûr de vouloir supprimer cette sauvegarde ?')) {
      try {
        const { deleteSVG } = await import('../../../backend/pocketbase/pb.js');
        await deleteSVG(id);
        location.reload();
      } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        alert(translations.deleteError || 'Erreur lors de la suppression');
      }
    }
  }

  // Exposer les fonctions globalement pour les onclick
  (window as any).copySVGCode = copySVGCode;
  (window as any).deleteSVGItem = deleteSVGItem;

  // Fonction pour copier le code SVG (version avec attributs data)
  async function copySVGCodeData(id: string, code: string) {
    try {
      await navigator.clipboard.writeText(code);
      
      // Feedback visuel
      const button = document.querySelector(`[data-copy-id="${id}"]`);
      if (button) {
        const originalText = button.textContent;
        button.textContent = 'Copié !';
        button.classList.add('btn-success');
        
        setTimeout(() => {
          button.textContent = originalText;
          button.classList.remove('btn-success');
        }, 2000);
      }
    } catch (err) {
      console.error('Erreur lors de la copie:', err);
      alert(translations.copyError || 'Erreur lors de la copie du code');
    }
  }

  // Fonction pour supprimer un SVG (version avec attributs data)
  async function deleteSVGData(id: string) {
    if (!confirm(translations.confirmDelete || 'Êtes-vous sûr de vouloir supprimer ce SVG ?')) {
      return;
    }

    try {
      const { deleteSVG } = await import('../../../backend/pocketbase/pb.js');
      await deleteSVG(id);
      
      // Supprimer l'élément du DOM
      const svgCard = document.querySelector(`[data-svg-id="${id}"]`);
      if (svgCard) {
        svgCard.remove();
      }
      
      alert(translations.deleteSuccess || 'SVG supprimé avec succès !');
      
      // Vérifier s'il reste des SVG
      const remainingSVGs = document.querySelectorAll('[data-svg-id]');
      if (remainingSVGs.length === 0) {
        location.reload(); // Recharger pour afficher le message "Aucun SVG trouvé"
      }
    } catch (error) {
      console.error('Erreur lors de la suppression:', error);
      alert(translations.deleteError || 'Erreur lors de la suppression');
    }
  }

  // Attacher les événements aux boutons (version data attributes)
  document.addEventListener('DOMContentLoaded', () => {
    // Boutons de copie
    document.querySelectorAll('[data-copy-id]').forEach(button => {
      button.addEventListener('click', () => {
        const id = button.getAttribute('data-copy-id');
        const code = button.getAttribute('data-copy-code');
        if (id && code) {
          copySVGCodeData(id, code);
        }
      });
    });

    // Boutons de suppression
    document.querySelectorAll('[data-delete-id]').forEach(button => {
      button.addEventListener('click', () => {
        const id = button.getAttribute('data-delete-id');
        if (id) {
          deleteSVGData(id);
        }
      });
    });

    // === SYSTÈME DE FILTRAGE ===
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const tagFilter = document.getElementById('tag-filter') as HTMLSelectElement;
    const svgList = document.getElementById('svg-list');
    const noResults = document.getElementById('no-results');
    
    // Récupérer tous les SVG cards
    const getAllCards = () => Array.from(document.querySelectorAll('[data-svg-id]')) as HTMLElement[];
    
    // Collecter tous les tags uniques
    const collectAllTags = () => {
      const tags = new Set<string>();
      getAllCards().forEach(card => {
        const cardTags = card.getAttribute('data-tags');
        if (cardTags) {
          cardTags.split(',').forEach(tag => {
            const trimmed = tag.trim();
            if (trimmed) tags.add(trimmed);
          });
        }
      });
      return Array.from(tags).sort();
    };

    // Populer le select avec les tags
    const populateTagFilter = () => {
      const allTags = collectAllTags();
      const currentValue = tagFilter.value;
      
      // Garder l'option "Tous les Tags"
      tagFilter.innerHTML = `<option value="">${translations.allTags || 'All Tags'}</option>`;
      
      // Ajouter les tags
      allTags.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        tagFilter.appendChild(option);
      });
      
      // Restaurer la sélection
      if (currentValue) tagFilter.value = currentValue;
    };

    // Fonction de filtrage
    const filterCards = () => {
      const searchTerm = searchInput?.value.toLowerCase() || '';
      const selectedTag = tagFilter?.value || '';
      const cards = getAllCards();
      
      let visibleCount = 0;
      
      cards.forEach(card => {
        const name = (card.getAttribute('data-name') || '').toLowerCase();
        const tags = card.getAttribute('data-tags') || '';
        const tagArray = tags.split(',').map(t => t.trim());
        
        // Vérifier les conditions de filtrage
        const matchesSearch = !searchTerm || name.includes(searchTerm);
        const matchesTag = !selectedTag || tagArray.includes(selectedTag);
        
        // Afficher/Masquer la card
        if (matchesSearch && matchesTag) {
          card.style.display = '';
          visibleCount++;
        } else {
          card.style.display = 'none';
        }
      });
      
      // Afficher/masquer le message "Aucun résultat"
      if (noResults) {
        if (visibleCount === 0 && cards.length > 0) {
          noResults.classList.remove('hidden');
        } else {
          noResults.classList.add('hidden');
        }
      }
    };

    // Initialiser les tags
    populateTagFilter();
    
    // Écouter les changements
    searchInput?.addEventListener('input', filterCards);
    tagFilter?.addEventListener('change', filterCards);
    
    // Écouter les mises à jour de tags (custom event)
    document.addEventListener('tagsUpdated', () => {
      populateTagFilter();
      filterCards();
    });
  });

  // === GESTION DES TAGS ===
  let currentSvgId = '';
  let currentTagIds: string[] = [];
  let allAvailableTags: any[] = [];

  // Charger tous les tags de l'utilisateur
  async function loadAllTags() {
    try {
      const response = await fetch('/api/tags/list');
      const data = await response.json();
      if (data.success) {
        allAvailableTags = data.tags;
      }
    } catch (error) {
      console.error('Error loading tags:', error);
    }
  }

  // Charger les tags au démarrage
  loadAllTags();

  (window as any).openTagModal = async (svgId: string, svgName: string, tagIds: string[]) => {
    currentSvgId = svgId;
    
    // S'assurer que tous les tags sont chargés
    await loadAllTags();
    
    // Récupérer les tags à jour depuis la base de données
    try {
      const svgResponse = await fetch(`/api/svg/getTags?svgId=${svgId}`);
      const svgData = await svgResponse.json();
      
      // Mettre à jour avec les vrais tagIds depuis la base
      if (svgData.success && svgData.tagIds) {
        currentTagIds = svgData.tagIds;
        
        // Si l'API retourne aussi les objets tags complets, les ajouter à allAvailableTags
        if (svgData.tags && svgData.tags.length > 0) {
          svgData.tags.forEach((tag: any) => {
            if (!allAvailableTags.find(t => t.id === tag.id)) {
              allAvailableTags.push(tag);
            }
          });
        }
      } else {
        currentTagIds = [];
      }
    } catch (error) {
      console.error('Error loading SVG tags:', error);
      // Fallback sur les tagIds passés en paramètre
      currentTagIds = Array.isArray(tagIds) ? tagIds : [];
    }
    
    const modal = document.getElementById('tag-modal') as HTMLDialogElement;
    const modalTitle = document.getElementById('modal-svg-name');
    
    if (modalTitle) modalTitle.textContent = svgName;
    
    // Ajouter un petit log pour debug
    console.log('Opening modal - currentTagIds:', currentTagIds);
    console.log('Opening modal - allAvailableTags:', allAvailableTags);
    
    renderCurrentTags();
    renderAvailableTags();
    
    modal?.showModal();
  };

  function renderCurrentTags() {
    const tagsList = document.getElementById('current-tags');
    if (!tagsList) return;
    
    const currentTags = allAvailableTags.filter(tag => currentTagIds.includes(tag.id));
    
    tagsList.innerHTML = currentTags.length > 0 
      ? currentTags.map(tag => `
          <div class="badge gap-2" style="background-color: ${tag.color || '#3B82F6'}; color: white;">
            ${tag.name}
            <button class="btn btn-ghost btn-xs btn-circle" onclick="removeTagFromSvg('${tag.id}')">✕</button>
          </div>
        `).join('')
      : `<p class="text-sm text-base-content/60">${translations.noResults || 'No tags yet'}</p>`;
  }

  function renderAvailableTags() {
    const availableList = document.getElementById('available-tags');
    if (!availableList) return;
    
    // Tags non encore assignés au SVG
    const availableTags = allAvailableTags.filter(tag => !currentTagIds.includes(tag.id));
    
    availableList.innerHTML = availableTags.length > 0
      ? availableTags.map(tag => `
          <button 
            class="badge badge-outline gap-2 cursor-pointer hover:badge-primary"
            onclick="addTagToSvg('${tag.id}')"
            style="border-color: ${tag.color || '#3B82F6'};"
          >
            ${tag.name}
            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
          </button>
        `).join('')
      : `<p class="text-sm text-base-content/60">${translations.allTagsAssigned || 'All tags assigned'}</p>`;
  }

  (window as any).removeTagFromSvg = async (tagId: string) => {
    currentTagIds = currentTagIds.filter(id => id !== tagId);
    await updateSvgTags();
  };

  (window as any).addTagToSvg = async (tagId: string) => {
    if (!currentTagIds.includes(tagId)) {
      currentTagIds.push(tagId);
      await updateSvgTags();
    }
  };

  (window as any).createNewTag = async () => {
    const input = document.getElementById('new-tag-input') as HTMLInputElement;
    const colorInput = document.getElementById('new-tag-color') as HTMLInputElement;
    const tagName = input.value.trim();
    const tagColor = colorInput.value;
    
    if (!tagName) return;
    
    try {
      const response = await fetch('/api/tags/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: tagName, color: tagColor }),
      });

      const data = await response.json();
      
      if (response.ok && data.success) {
        // Ajouter le nouveau tag à la liste globale
        allAvailableTags.push(data.tag);
        
        // Ajouter le tag au SVG actuel
        currentTagIds.push(data.tag.id);
        
        // Sauvegarder les modifications
        await updateSvgTags();
        
        // Forcer le re-render des tags après l'update
        renderCurrentTags();
        renderAvailableTags();
        
        // Réinitialiser les inputs
        input.value = '';
        colorInput.value = '#3B82F6';
        
        alert(translations.tagCreated || 'Tag created!');
      } else if (response.status === 409) {
        alert(translations.tagAlreadyExists || 'Tag already exists!');
      } else {
        alert(data.error || (translations.tagError || 'Error creating tag'));
      }
    } catch (error) {
      console.error('Error creating tag:', error);
      alert(translations.tagError || 'Error creating tag');
    }
  };

  (window as any).deleteTag = async (tagId: string) => {
    if (!confirm(translations.deleteTagConfirm || 'Delete this tag? It will be removed from all SVGs.')) return;
    
    try {
      const response = await fetch('/api/tags/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tagId }),
      });

      if (response.ok) {
        // Retirer le tag de la liste
        allAvailableTags = allAvailableTags.filter(tag => tag.id !== tagId);
        currentTagIds = currentTagIds.filter(id => id !== tagId);
        
        renderCurrentTags();
        renderAvailableTags();
        
        alert(translations.tagRemoved || 'Tag deleted!');
        
        // Recharger la page pour mettre à jour toutes les cards
        setTimeout(() => location.reload(), 1000);
      }
    } catch (error) {
      console.error('Error deleting tag:', error);
      alert(translations.tagError || 'Error deleting tag');
    }
  };

  // === GESTION GLOBALE DES TAGS ===
  (window as any).openManageTagsModal = async () => {
    await loadAllTags(); // Recharger les tags
    renderAllTagsList();
    const modal = document.getElementById('manage-tags-modal') as HTMLDialogElement;
    modal?.showModal();
  };

  function renderAllTagsList() {
    const listContainer = document.getElementById('all-tags-list');
    if (!listContainer) return;
    
    if (allAvailableTags.length === 0) {
      listContainer.innerHTML = `<p class="text-sm text-base-content/60">${translations.noTagsYet || 'No tags yet. Create your first tag!'}</p>`;
      return;
    }
    
    listContainer.innerHTML = allAvailableTags.map(tag => `
      <div class="flex items-center justify-between p-3 bg-base-200 rounded-lg hover:bg-base-300 transition-colors">
        <div class="flex items-center gap-3">
          <div class="w-6 h-6 rounded" style="background-color: ${tag.color || '#3B82F6'}"></div>
          <span class="font-medium">${tag.name}</span>
        </div>
        <button 
          class="btn btn-ghost btn-sm btn-square text-error"
          onclick="deleteTagPermanent('${tag.id}')"
          title="Delete tag"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
          </svg>
        </button>
      </div>
    `).join('');
  }

  (window as any).createTagFromManage = async () => {
    const input = document.getElementById('manage-new-tag-input') as HTMLInputElement;
    const colorInput = document.getElementById('manage-new-tag-color') as HTMLInputElement;
    const tagName = input.value.trim();
    const tagColor = colorInput.value;
    
    if (!tagName) return;
    
    try {
      const response = await fetch('/api/tags/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: tagName, color: tagColor }),
      });

      const data = await response.json();
      
      if (response.ok && data.success) {
        // Ajouter le nouveau tag à la liste
        allAvailableTags.push(data.tag);
        renderAllTagsList();
        
        // Réinitialiser les inputs
        input.value = '';
        colorInput.value = '#3B82F6';
        
        alert(translations.tagCreated || 'Tag created!');
      } else if (response.status === 409) {
        alert(translations.tagAlreadyExists || 'Tag already exists!');
      } else {
        alert(data.error || (translations.tagError || 'Error creating tag'));
      }
    } catch (error) {
      console.error('Error creating tag:', error);
      alert(translations.tagError || 'Error creating tag');
    }
  };

  (window as any).deleteTagPermanent = async (tagId: string) => {
    if (!confirm(translations.deleteTagConfirm || 'Delete this tag permanently? It will be removed from all SVGs.')) return;
    
    try {
      const response = await fetch('/api/tags/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tagId }),
      });

      if (response.ok) {
        // Retirer le tag de la liste
        allAvailableTags = allAvailableTags.filter(tag => tag.id !== tagId);
        renderAllTagsList();
        
        alert(translations.tagRemoved || 'Tag deleted!');
        
        // Recharger la page après 1 seconde pour mettre à jour toutes les cards
        setTimeout(() => location.reload(), 1000);
      }
    } catch (error) {
      console.error('Error deleting tag:', error);
      alert(translations.tagError || 'Error deleting tag');
    }
  };

  async function updateSvgTags() {
    try {
      const response = await fetch('/api/updateTags', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          svgId: currentSvgId,
          tagIds: currentTagIds,
        }),
      });

      if (response.ok) {
        // Recharger les tags
        renderCurrentTags();
        renderAvailableTags();
        
        // Mettre à jour la card dans le DOM
        const card = document.querySelector(`[data-svg-id="${currentSvgId}"]`) as HTMLElement;
        if (card) {
          const currentTags = allAvailableTags.filter(tag => currentTagIds.includes(tag.id));
          const tagNames = currentTags.map(t => t.name).join(',');
          card.setAttribute('data-tags', tagNames);
          card.setAttribute('data-tag-ids', currentTagIds.join(','));
          
          // Trouver ou créer le conteneur de badges dans la card
          let badgesContainer = card.querySelector('.flex.flex-wrap.gap-1.mb-2');
          
          if (!badgesContainer && currentTags.length > 0) {
            // Si le conteneur n'existe pas et qu'on a des tags, le créer
            const cardBody = card.querySelector('.card-body');
            const titleContainer = card.querySelector('.flex.justify-between.items-start.mb-3');
            
            if (cardBody && titleContainer) {
              badgesContainer = document.createElement('div');
              badgesContainer.className = 'flex flex-wrap gap-1 mb-2';
              // Insérer après le titre
              titleContainer.insertAdjacentElement('afterend', badgesContainer);
            }
          }
          
          // Mettre à jour l'affichage des tags dans la card
          if (badgesContainer) {
            if (currentTags.length > 0) {
              badgesContainer.innerHTML = currentTags.map(tag => `
                <span class="badge badge-sm" style="background-color: ${tag.color || '#3B82F6'}; color: white;">
                  ${tag.name}
                </span>
              `).join('');
            } else {
              // Supprimer le conteneur s'il n'y a plus de tags
              badgesContainer.remove();
            }
          }
        }
        
        // Trigger l'événement pour mettre à jour les filtres
        document.dispatchEvent(new Event('tagsUpdated'));
      }
    } catch (error) {
      console.error('Error updating tags:', error);
      alert(translations.tagError || 'Error managing tags');
    }
  }
</script>

<!-- Modal de gestion des tags -->
<dialog id="tag-modal" class="modal">
  <div class="modal-box max-w-2xl">
    <h3 class="font-bold text-lg mb-2">{ui[locale].gallery.manageTags}</h3>
    <p class="text-sm text-base-content/70 mb-4" id="modal-svg-name"></p>
    
    <!-- Tags actuels du SVG -->
    <div class="mb-4">
      <label class="label">
        <span class="label-text font-semibold">{ui[locale].gallery.currentTags}</span>
      </label>
      <div id="current-tags" class="flex flex-wrap gap-2 min-h-[2rem] p-3 bg-base-200 rounded-lg">
        <p class="text-sm text-base-content/60">{ui[locale].gallery.noResults}</p>
      </div>
    </div>
    
    <!-- Tags disponibles -->
    <div class="mb-4">
      <label class="label">
        <span class="label-text font-semibold">{ui[locale].gallery.availableTags}</span>
      </label>
      <div id="available-tags" class="flex flex-wrap gap-2 min-h-[2rem] p-3 bg-base-100 border-2 border-dashed border-base-300 rounded-lg">
        <p class="text-sm text-base-content/60">Loading...</p>
      </div>
    </div>
    
    <!-- Créer un nouveau tag -->
    <div class="form-control">
      <label class="label">
        <span class="label-text font-semibold">{ui[locale].gallery.createTag}</span>
      </label>
      <div class="flex gap-2">
        <input 
          type="text" 
          id="new-tag-input"
          placeholder={ui[locale].gallery.enterTagName}
          class="input input-bordered flex-1"
          onkeypress="if(event.key === 'Enter') { event.preventDefault(); createNewTag(); }"
        />
        <input 
          type="color" 
          id="new-tag-color"
          value="#3B82F6"
          class="input input-bordered w-16"
          title="Tag color"
        />
        <button class="btn btn-primary" onclick="createNewTag()">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
          </svg>
          {ui[locale].gallery.createTag}
        </button>
      </div>
    </div>
    
    <div class="modal-action">
      <form method="dialog">
        <button class="btn">{ui[locale].gallery.close}</button>
      </form>
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>

<!-- Modal de gestion globale des tags -->
<dialog id="manage-tags-modal" class="modal">
  <div class="modal-box max-w-2xl">
    <h3 class="font-bold text-lg mb-4">{ui[locale].gallery.manageAllTags}</h3>
    
    <!-- Créer un nouveau tag -->
    <div class="form-control mb-6">
      <label class="label">
        <span class="label-text font-semibold">{ui[locale].gallery.createNewTag}</span>
      </label>
      <div class="flex gap-2">
        <input 
          type="text" 
          id="manage-new-tag-input"
          placeholder={ui[locale].gallery.enterTagName}
          class="input input-bordered flex-1"
          onkeypress="if(event.key === 'Enter') { event.preventDefault(); createTagFromManage(); }"
        />
        <input 
          type="color" 
          id="manage-new-tag-color"
          value="#3B82F6"
          class="input input-bordered w-16"
          title="Tag color"
        />
        <button class="btn btn-primary" onclick="createTagFromManage()">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
          </svg>
          {ui[locale].gallery.createTag}
        </button>
      </div>
    </div>
    
    <!-- Liste de tous les tags -->
    <div>
      <label class="label">
        <span class="label-text font-semibold">{ui[locale].gallery.allYourTags}</span>
      </label>
      <div id="all-tags-list" class="space-y-2 max-h-96 overflow-y-auto">
        <p class="text-sm text-base-content/60">Loading...</p>
      </div>
    </div>
    
    <div class="modal-action">
      <form method="dialog">
        <button class="btn">{ui[locale].gallery.close}</button>
      </form>
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>